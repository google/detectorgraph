<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DetectorGraph: Atomic/Consistent Detector Data Store</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DetectorGraph
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Atomic/Consistent <a class="el" href="classDetectorGraph_1_1Detector.html" title="A unit of logic in a DetectorGraph. ">Detector</a> Data Store </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#data-store-intro">Introduction</a></li>
<li class="level1"><a href="#data-store-cacheall">The naive solution</a></li>
<li class="level1"><a href="#data-store-topic-introspection">Topic Introspection</a></li>
<li class="level1"><a href="#data-store-service">Detector Data Store Service</a></li>
<li class="level1"><a href="#data-store-conclusion">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="data-store-intro"></a>
Introduction</h1>
<p><a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a> removes from the detectors the responsability (and freedom) to store and serve its state alongside with performing computation. We belive that's a design advantage but that clearly leaves opens a gap of functionality when compared to our current <a class="el" href="namespaceDetectorGraph.html">DetectorGraph</a>. That gap needs to be addressed. The following are our current uses of such functionality:</p><ol type="1">
<li>a <em>DetectorA</em> uses the sate of a <em>DetectorB</em> without actually subscribing to <em>DetectorB</em></li>
<li>a <em>DetectorA</em> Publishes outgoing data consumed by <em>Consumer1</em> (e.g. AppThread) which in turn inspects a (locked) graph for the states of <em>DetectorA</em>, <em>DetectorB</em>, .. <em>DetectorX</em> to form a complete opinion.</li>
<li>a <em>DetectorA</em> wants to save/resume it's state (desired)</li>
</ol>
<p>The design constraints for this solution are:</p><ol type="1">
<li>Retrieving this state should be 'atomic' in relation to graph evaluations; this means that all values returned should be product of the same evaluation pass.</li>
<li>The retrieved state should be "the most up-to-date" possible.</li>
</ol>
<p>This section lists a few approaches to close that gap.</p>
<h1><a class="anchor" id="data-store-cacheall"></a>
The naive solution</h1>
<p>The most simple solution to this would be to compose the needed state on the <em>Consumer</em> side by subscribing to all events that compose it and inpecting it when needed. This solution has a number of inefficiencies and one major flaw:</p>
<p>The consumer would demand awareness of the boundaries between evaluation passes and only use the state at the end of it. Say <em>Consumer</em> needs to know <em>StateB</em> when it receives an update to <em>StateA</em>, caching would only work if <em>StateB</em> updates are produced before <em>StateA</em> updates - so it's dependent on the order events are emitted. To solve this you'd need a <em>AllEventsEmitted</em> event... you get it: it gets ugly before you can say quick.</p>
<h1><a class="anchor" id="data-store-topic-introspection"></a>
Topic Introspection</h1>
<p>Another suggested solution is to allow a consumer to safely introspection topics in between evaluations of the graph. This appears to be the smallest effort solution given the role that topics play on the graph. This approach has a few advantages and disadvantages:</p>
<p>Advantages:</p><ul>
<li>The latest state is returned by design</li>
<li>No extra possible points of failure or latency between what the graph sees and what the <em>Consumer</em> would see.</li>
<li>No concepts added, logical extension of previous design.</li>
</ul>
<p>Disadvantages:</p><ul>
<li>Introducing locking/multi-threading mechanisms into topics and/or graph adds application complexity to the basic detector graph.</li>
<li>Locking the graph means the application can interfere with the performance of the graph as a computation framework.</li>
<li><a class="el" href="classDetectorGraph_1_1Topic.html" title="Manage data and its handler. ">Topic</a> is a sensitive class when it comes to code size due to its templated nature.</li>
<li>Many of topics have very local/detector-specific nature (timeouts, internals) and exposing access to it can be seen as an anti-pattern that will mix public &amp; private workings of the graph.</li>
</ul>
<p>We believe the disadvantages outweighs the advantages when it comes to code quality and excellence even though this approach might seem as the smallest effort one.</p>
<h1><a class="anchor" id="data-store-service"></a>
Detector Data Store Service</h1>
<p>Following ROS's inspiration, its concept of <em>Services</em> lands itself nicely to the idea of an entity that provides a complete snapshot of the graph's state through a atomic method call. If implemented correctly, a <em>DetectorStateStoreService</em> could ensure state atomicity/consistency as a single-stop shop for all needed states. This solution extends the loose coupling across detectors to consumers (e.g. app).</p>
<h1><a class="anchor" id="data-store-conclusion"></a>
Conclusion</h1>
<p>See <a class="el" href="classDetectorGraph_1_1GraphStateStore.html" title="A StateSnapshot keeper for DetectorGraph TopicStates. ">GraphStateStore</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
